declare module "odin" {
    /**
     * 输出Log
     * @param content 内容
     */
    export function oTrace(...content: any[]): void;
    /**
     * 输出Warning
     * @param content 内容
     */
    export function oTraceWarning(...content: any[]): void;
    /**
     * 输出Error
     * @param content 内容
     */
    export function oTraceError(...content: any[]): void;
    export class LogManager {
        static instance: LogManager;
        private logLevel;
        private _firstWithEnable;
        private cs;
        constructor();
        destroy(): void;
        /**
         * 设置所有的打印是否带______[OdinLog]前缀
         */
        set firstWithEnable(value: boolean);
        /**
         * 设置输出的等级
         * @param value 等级值(0-全部 1-Error&Warning 2-Error)
         */
        setLogLevel(value: number): void;
        /**
         * 输出Log
         * @param content 内容
         */
        log(...content: any[]): void;
        /**
         * 输出Warning
         * @param content 内容
         */
        logWarning(...content: any[]): void;
        /**
         * 输出Error
         * @param content 内容
         */
        logError(...content: any[]): void;
        /**
         * 输出带tag的Log，便于搜索
         * @param tag tag
         * @param content 内容
         */
        logWithTag(tag: string, ...content: any[]): void;
        /**
         * 输出带tag的Warning，便于搜索
         * @param tag tag
         * @param content 内容
         */
        logWarningWithTag(tag: string, ...content: any[]): void;
        /**
         * 输出带tag的Error，便于搜索
         * @param tag tag
         * @param content 内容
         */
        logErrorWithTag(tag: string, ...content: any[]): void;
        private getFirstWith;
    }
}

declare module "odin" {
    /**判断当前是否是单机模式 */
    export function isListenServer(): boolean;
    /**
    * 类定义，使用这个可以省去类参数繁琐的类型声明    如:fun<T>(c:{new():T}) 可以写成 fun<T>(c:Class<T>)
    */
    export interface Class<T> extends Function {
        new (...args: any[]): T;
    }
    /**
     * 类装饰器-自动init，可以自动调用类的静态init方法
     * @param target 类目标
     */
    export function AutoInit(target: any): void;
    /**
     * 方法装饰器-无返回服务器网络方法，用于装饰不需要给客户端返回reply的net方法
     * @param target 类实例
     * @param funName 方法名
     * @param descriptor 属性描述
     */
    export function NoReply(target: Object, funName: string, descriptor: PropertyDescriptor): void;
    /**
     * 可以被序列化的Map
     */
    export type ObjMap<T> = {
        [key: string]: T;
    };
    /**回调体，用于Action和Event系统的辅助功能*/
    export class CallBack {
        private fun;
        private thisArg;
        dirty: boolean;
        constructor(fun: Function, thisArg: any);
        call(...prames: any[]): any;
        isOriginFrom(fun: Function, thisArg: any): boolean;
        get originFun(): Function;
        get originThisArg(): any;
    }
    /**任意参数的代理*/
    export class Action {
        private callBackList;
        private callingRemNum;
        private countChangeCallback;
        /**
         * 添加一个监听方法(有重复过滤)
         * @param fn 方法
         * @param thisArg 域
         */
        add(fn: Function, thisArg?: any): void;
        /**
         * 移除一个监听方法
         * @param fn 方法
         * @param thisArg 域
         */
        remove(fn: Function, thisArg: any): void;
        /**
         * 执行
         * @param prams 参数序列
         */
        call(...prams: any): void;
        /**
         * 判断是否包含某个监听方法
         * @param fn 方法
         * @param thisArg 域
         * @returns 结果
         */
        includes(fn: Function, thisArg: any): boolean;
        /**
         * 清除所有监听
         */
        clear(): void;
        /**
         * 监听方法的数量
         */
        get count(): number;
        /**
         * 设置长度变化的回调方法
         * @param callback 方法
         */
        setCountChangeCallback(callback: Function): void;
        private getFunIndex;
        private getCallBack;
    }
    /**一个参数的代理*/
    export class Action1<T> extends Action {
        add(fn: (a: T) => void, thisArg?: any): void;
        remove(fn: (a: T) => void, thisArg: any): void;
        call(arg: T): void;
    }
    /**二个参数的代理*/
    export class Action2<T, S> extends Action {
        add(fn: (a: T, b: S) => void, thisArg?: any): void;
        remove(fn: (a: T, b: S) => void, thisArg: any): void;
        call(a: T, b: S): void;
    }
    export function Singleton(): (type: {
        new ();
        instance: any;
    }) => {
        new (): any;
        instance: any;
    };
}

declare module "odin" {
    export class DataInfo {
        version: number;
    }
}

declare module "odin" {
    export class PlayerData {
        private playerId;
        private dataMap;
        private moduleDataMap;
        constructor(playerId: number, dataMap: any);
        getModuleData<T extends ModuleData<any>>(ModuleDataClass: Class<T>): T;
        get dataInfoMap(): any;
        destroy(): void;
    }
}

declare module "odin" {
    export class DataCenterS {
        private static _instance;
        private constructor();
        static get instance(): DataCenterS;
        destroy(): void;
        private readonly INIT_PLAYER_DATA_ASK;
        private readonly INIT_PLAYER_DATA_REPLY;
        private readonly PLAYER_DATA_CHANGE_NOTIFY;
        private readonly SAVE_DELAY_SECOND;
        readonly onPlayerJoined: Action1<GamePlay.Player>;
        readonly onPlayerLeft: Action1<GamePlay.Player>;
        private playerDataMap;
        private toBeSavedMap;
        private onlinePlayerIds;
        /**初始化(框架方法，请勿调用) */
        init(): void;
        private loadPlayerData;
        private unloadPlayerData;
        private savePlayerData;
        /**
         * 获取一个玩家的数据
         * @param player 玩家
         * @returns 玩家数据
         */
        getPlayerData(player: GamePlay.Player | number): PlayerData;
        /**
         * 获取一个玩家的一个模块数据
         * @param player 玩家
         * @param ModuleDataClass 模块数据类
         * @returns 模块数据对象
         */
        getModuleData<T extends ModuleData<DataInfo>>(player: GamePlay.Player | number, ModuleDataClass: Class<T>): T;
        /**
         * 存储模块数据
         * @param moduleData 模块数据
         * @returns 是否成功
         */
        saveModuleData(moduleData: ModuleData<any>, syncToClient: boolean): boolean;
        /**
         * 同步模块数据(只向客户端同步，不保存)
         * @param moduleData 模块数据对象
         */
        syncModuleData(moduleData: ModuleData<any>): void;
        /**
         * 获取在线的所有玩家的ID数组
         * @returns 在线玩家id数组
         */
        getPlayerIDs(): Array<number>;
    }
}

declare module "odin" {
    export class ModuleData<T extends DataInfo> {
        /** 服务器同步数据的事件(Client Only)*/
        readonly onDataChange: Action;
        private syncActionNetMsg;
        private _playerId;
        private DataInfoClass;
        private dataInfoMap;
        private syncToClient;
        protected constructor(DataInfoClass: Class<T>);
        private init;
        private destroy;
        /**数据体*/
        protected get dataInfo(): T;
        /**数据名称*/
        get dataName(): string;
        /**所属玩家id*/
        get playerId(): number;
        /**
         * 初始化默认数据，需要请复写
         */
        protected initDefaultData(): void;
        /**
         * 数据初始化完成调用，需要请复写
         */
        protected onDataInit(): void;
        /**
         * 保存模块数据(Server Only)
         * @param syncToClient 是否同步给客户端
         * @returns 模块数据自身
         */
        saveData(syncToClient: boolean): this;
        /**
         * 向客户端同步模块数据(Server Only)
         * @returns 模块数据自身
         */
        syncData(): this;
    }
}

declare module "odin" {
    export class DataCenterC {
        private static _instance;
        private constructor();
        static get instance(): DataCenterC;
        destroy(): void;
        private readonly INIT_PLAYER_DATA_ASK;
        private readonly INIT_PLAYER_DATA_REPLY;
        private readonly PLAYER_DATA_CHANGE_NOTIFY;
        private playerData;
        /**
         * 初始化，获取当前玩家的所有模块数据
         */
        init(): Promise<void>;
        /**
         * 获取自己的一个模块数据
         * @param ModuleDataClass 模块数据类
         * @returns 模块数据对象
         */
        getModuleData<T extends ModuleData<DataInfo>>(ModuleDataClass: Class<T>): T;
        /**判断UIRoot是否就绪*/
        ready(): Promise<void>;
    }
}

declare module "odin" {
    export class TimeUtil {
        /**进入帧事件(参数dt)*/
        static readonly onEnterFrame: Action1<number>;
        private static delayExecuteFun;
        private static delayExecuteId;
        private static _delayTime;
        /**每一帧经过的时间 (单位：秒) */
        static get delayTime(): number;
        /** 游戏运行后所经过的总时长 (单位：秒)*/
        static get time(): number;
        /**
         * 延迟一定帧数执行方法
         * @param fun 执行的方法
         * @param frameNum 要延迟的帧数
         * @returns 用于停止的id
         */
        static delayExecute(fun: Function, frameNum?: number): number;
        /**
         * 清除delayExecute
         * @param id delayExecute方法返回的id
         */
        static clearDelayExecute(id: number): void;
        /**
         * 延迟一定秒数,用于异步方法中间的等待
         * @param second 时间(单位：秒)
         * @returns Promise
         */
        static delaySecond(second: number): Promise<void>;
        /**
         * 给主循环留的接口，不要调用
         * @param dt 两帧直接的时间差
         */
        static update(dt: number): void;
        private static delayExecuteUpdate;
    }
}

declare module "odin" {
    export class NetManager {
        private static _instance;
        static get instance(): NetManager;
        private constructor();
        private static init;
        destroy(): void;
        private readonly ASK;
        private readonly REPLY;
        private readonly NOTIFY;
        private readonly NO_REPLY;
        private _logVisible;
        private funMap;
        private objFunMap;
        private objMap;
        private waitServerResolveMap;
        private noReplyFunNameMap;
        private _currentPlayer;
        private _rpcCount;
        /**是否显示通信log */
        set logVisible(value: boolean);
        /**当前调用服务器方法的玩家*/
        get currentPlayer(): GamePlay.Player;
        /**发送和接收的rpc总数量*/
        get rpcCount(): number;
        /**初始化(框架方法，请勿调用) */
        private init;
        /**
         * 注册网络方法(网络方法是可以被远端调用的， 注意：注册的方法名不能重复)
         * @param fun 方法
         * @param thisArg 方法的域
         * @param callName 调用别名(默认为方法名)
         */
        registerFun(fun: Function, thisArg: any, callName?: string): void;
        /**
         * 移除注册的网络方法
         * @param fun 方法
         */
        unRegisterFun(fun: Function): void;
        /**
         * 注册网络对象(网络对象里的方法都是可以被远端调用的)
         * @param netObj 网络对象
         * @param netGuid 通信id
         */
        registerObj(netObj: any, netGuid: string): void;
        /**
         * 移除注册的网络对象
         * @param netObj 对象
         */
        unRegisterObj(netObj: any): void;
        /**
         * 调用服务端方法
         * @param fun 方法路径|方法
         * @param params 参数
         * @returns 服务端方法返回值(异步)
         */
        callServerFun(fun: string | Function, ...params: any[]): Promise<any>;
        /**
         * 调用目标客户端的方法
         * @param player 目标玩家
         * @param fun 方法路径|方法
         * @param params 参数
         */
        callClientFun(player: GamePlay.Player | number, fun: string | Function, ...params: any[]): void;
        /**
         * 调用目标玩家周围客户端的方法
         * @param fun 方法路径|方法
         * @param params 参数
         */
        callAroundClientFun(fun: string | Function, ...params: any[]): void;
        /**
         * 调用所有客户端的方法
         * @param fun 方法路径|方法
         * @param params 参数
         */
        callWorldClientFun(fun: string | Function, ...params: any[]): void;
        private getFunction;
        private showLog;
    }
}

declare module "odin" {
    /**字符串工具*/
    export class StringUtil {
        /**
         * 判断字符串是否为空(null或"")
         * @param str 要判断的字符串
         * @returns 结果
         */
        static isEmpty(str: string): boolean;
        /**
         * 将{i}中的内容依次替换为后续参数,i从0开始
         * @param str 要处理的字符串
         * @param param 替换序列
         * @returns 新的字符串
         */
        static format(str: string, ...param: any[]): string;
        /**
         * 将秒数转换为时分秒的形式
         * @param second 秒数
         * @param style 字符串样式默认为,默认为"{0}:{1}:{2}"
         * @returns 转化后的字符串
         */
        static secondToHMS(second: number, style?: string): string;
    }
}

declare module "odin" {
    export class GoNode {
        name: string;
        guid: string;
        parentGuid: string;
        children: Array<GoNode>;
        /**
         * 获取gameObject的节点树数据
         * @param go GameObject
         * @param ignoreServerOnly 忽略单Server的节点(用于客户端请求)
         * @returns 节点树数据
         */
        static get(go: MWCore.GameObject, ignoreServerOnly: boolean): GoNode;
        /**
         * 根据名字获取节点的一个子节点
         * @param goNode 目标节点
         * @param name 名字
         * @returns 子节点
         */
        static getChildByName(goNode: GoNode, name: string): GoNode;
        /**
         * 根据名字获取节点的所有同名子节点
         * @param goNode 目标节点
         * @param name 名字
         * @returns 子节点序列
         */
        static getChildrenByName(goNode: GoNode, name: string): Array<GoNode>;
        /**
         * 根据guid获取节点的一个子节点
         * @param goNode 目标节点
         * @param guid guid
         * @returns 子节点
         */
        static getChildByGuid(goNode: GoNode, guid: string): GoNode;
        /**
         * 根据路径获取节点的一个子节点
         * @param goNode 目标节点
         * @param path 路径
         * @returns 子节点
         */
        static getChildByPath(goNode: GoNode, path: string): GoNode;
        /**
         * 获取节点某个路径下的所有子节点
         * @param goNode 目标节点
         * @param path 路径
         * @returns 子节点序列
         */
        static getChildrenByPath(goNode: GoNode, path: string): Array<GoNode>;
        /**
         * 生成节点的树形结构字符串
         * @param goNode 目标节点
         * @returns 树形字符串
         */
        static getString(goNode: GoNode): string;
        private static getStringHandle;
    }
}

declare module "odin" {
    export class ResManager {
        private static _instance;
        static get instance(): ResManager;
        private constructor();
        private static init;
        destroy(): void;
        private _isInit;
        /**
         * 初始化，不要私自调用
         */
        private init;
        /**
         * 获取一个GameObject的节点结构(异步，双端调用)
         * @param guid gameObject的guid
         * @returns 节点树结构
         */
        loadGoNode(guid: string): Promise<GoNode>;
        /**
         * 根据路径查找场景中一个GameObject(异步，双端调用)
         * @param path 节点路径
         * @param waitTime 等待时间(单位：毫秒)
         * @returns GameObject
         */
        findGameObjectByPath<T extends MWCore.GameObject>(path: string, waitTime?: number): Promise<T>;
        /**
         * 根据guid查找场景中一个GameObject(异步，双端调用)
         * @param guid guid
         * @param waitTime 等待时间(单位：毫秒)
         * @returns GameObject
         */
        findGameObjectByGuid<T extends MWCore.GameObject>(guid: string, waitTime?: number): Promise<T>;
        /**
         * 根据guid查找场景中一个脚本(异步，双端调用)
         * @param guid guid
         * @param waitTime 等待时间(毫秒)
         * @returns 脚本
         */
        findScriptByGuid<T extends MWCore.MWScript>(guid: string, waitTime?: number): Promise<T>;
        private gameObjectIsOK;
        private netServerGetGameObjectNodeTreeByPath;
        private netServerGetGameObjectNodeTreeByGuid;
        private netServerGetGameObjectGuid;
        private getMWGameObject;
        private getRootMWGameObject;
        /**
         * 从GameObject获取子对象的guid (异步，双端调用)
         * @param targetGo 目标gameObject
         * @param path 节点路径
         * @returns guid
         */
        private getChildGuidFromGo;
        private getScriptGuidFromGo;
        /**
         * 根据路径从GameObject中查找一个子GameObject (异步 双端)
         * @param targetGo 目标GameObject
         * @param path 路径
         * @returns 子GameObject
         */
        findChildFromGo<T extends MWCore.GameObject>(targetGo: string | MWCore.GameObject, path: string): Promise<T>;
        /**
         * 根据路径从GameObject中查找一个脚本 (异步 双端)
         * @param targetGo 目标GameObject
         * @param path 路径
         * @returns 脚本对象
         */
        findScriptFromGo<T extends MWCore.MWScript>(targetGo: string | MWCore.GameObject, path: string): Promise<T>;
        private getGoGuid;
    }
}

declare module "odin" {
    export enum EffectPlayerType {
        Pos = 1,
        Player = 2,
        GameObject = 3
    }
    export class EffectData {
        private static currentPlayId;
        playId: number;
        resId: string;
        playType: EffectPlayerType;
        loopNum: number;
        targetGoGuid: string;
        targetPlayerId: number;
        socketType: GamePlay.CharacterSocketType;
        position: Type.Vector;
        rotation: Type.Rotation;
        scale: Type.Vector;
        private constructor();
        /**
         * 获取在一个坐标播放特效的数据
         * @param resGuid 特效资源guid
         * @param position 坐标
         * @param loopNum 循环次数(0无限)
         * @param rotation 角度
         * @returns 特效播放数据
         */
        static getPlayInPos(resGuid: string, position: Type.Vector, loopNum: number, rotation: Type.Rotation, scale: Type.Vector): EffectData;
        static getPlayInPlayer(resGuid: string, player: GamePlay.Player, socketType: GamePlay.CharacterSocketType, loopNum: number, offset: Type.Vector, rotation: Type.Rotation, scale: Type.Vector): EffectData;
        static getPlayInGameObject(resGuid: string, target: MWCore.GameObject, loopNum: number, offset: Type.Vector, rotation: Type.Rotation, scale: Type.Vector): EffectData;
        /**
         * 判断数据依赖的对象是否就绪
         * @param data 特效数据
         * @returns 是否就绪
         */
        static isReady(data: EffectData): boolean;
        /**
         * 判断一个特效数据是否依赖某个目标
         * @param effData 特效数据
         * @param targetId 目标id（GameObject的guid | 玩家的playerId）
         * @returns 是否依赖
         */
        static effIsDepend(effData: EffectData, targetId: string | number): boolean;
        private static getNewPlayId;
    }
}

declare module "odin" {
    /**特效 */
    export class Effect {
        private _resId;
        private go;
        private effectData;
        private isWaitParent;
        private startPlayTime;
        private _isDone;
        private loopTime;
        /**
         * 构造
         * @param resId 资源id
         */
        constructor(resId: string);
        private static isAssetId;
        private init;
        /**
         * 播放
         * @param data 播放的数据
         * @returns 播放的唯一标识
         */
        play(data: EffectData): number;
        private playHandle;
        /**
         * 是否依赖一个对象
         * @param targetId gameObejct的guid|player的playerId
         * @returns 结果
         */
        isDepend(targetId: string | number): boolean;
        /**停止*/
        stop(): void;
        /**编辑器特效对象 */
        get mwEffect(): GamePlay.EffectSystem;
        /**播放的唯一标识 */
        get playId(): number;
        /**资源id*/
        get resId(): string;
        /**是否播放完成*/
        get isDone(): boolean;
        /**
         * 刷新(架构方法请勿调用)
         * @returns 是否播放完成
         */
        update(dt: number): boolean;
        /**
         * 克隆
         * @returns 克隆的新对象
         */
        clone(): Effect;
    }
}

declare module "odin" {
    /**特效管理类 */
    export class EffectManager {
        private static _instance;
        static get instance(): EffectManager;
        private constructor();
        private static init;
        destroy(): void;
        private effectMap;
        private pool;
        private playingEffectArr;
        private playingEffectMap;
        private loopEffectDataOnServer;
        /**初始化(框架方法，请勿调用) */
        init(): void;
        private playEffect;
        /**
         * 在一个角色的挂点上播放特效（可双端调用)
         * @param resId 特效资源id
         * @param player 玩家
         * @param socketType 挂点类型
         * @param loopNum 循环次数(0为无限)
         * @param offset 坐标偏移
         * @param rotation 角度
         * @param scale 缩放
         * @returns 本次播放的唯一标识，可用于停止
         */
        playEffectInPlayer(resId: string, player: GamePlay.Player, socketType: GamePlay.CharacterSocketType, loopNum?: number, offset?: Type.Vector, rotation?: Type.Rotation, scale?: Type.Vector): number;
        /**
         * 在一个GameObject上播放特效（可双端调用)
         * @param resId 特效资源id
         * @param target 目标GameObject | 目标GameObject的guid
         * @param loopNum 循环次数(0为无限)
         * @param offset 坐标偏移
         * @param rotation 角度
         * @param scale 缩放
         * @returns 本次播放的唯一标识，可用于停止
         */
        playEffectInGameObject(resId: string, target: MWCore.GameObject, loopNum?: number, offset?: Type.Vector, rotation?: Type.Rotation, scale?: Type.Vector): number;
        /**
         * 在一个坐标上播放特效（可双端调用)
         * @param resId 特效资源id
         * @param pos 世界坐标
         * @param loopNum 循环次数(0为无限)
         * @param rotation 角度
         * @param scale 缩放
         * @returns 本次播放的唯一标识，可用于停止
         */
        playEffectInPos(resId: string, pos: Type.Vector, loopNum?: number, rotation?: Type.Rotation, scale?: Type.Vector): number;
        /**
         * 停止目标对象上所有资源id的特效（可双端调用)
         * @param resId 特效资源id
         * @param target 目标对象(Player或者GameObject)
         */
        stopEffectFromHost(resId: string, target?: GamePlay.Player | MWCore.GameObject): void;
        private stopEffectFromHost_Executor;
        /**
         * 停止一个特效的播放（可双端调用)
         * @param playId 播放id
         */
        stopEffect(playId: number): void;
        /**停止所有特效 */
        stopAllEffect(): void;
        /**
         * 根据播放id获取特效
         * @param playId 播放id
         * @returns 特效
         */
        private getEffect;
        private update;
        private spawnEffect;
        private returnEffect;
    }
}

declare module "odin" {
    export interface IModule {
        /**创建调用*/
        onAwake(): void;
        /**开始调用*/
        onStart(): void;
        /**刷新调用*/
        onUpdate(dt: number): void;
        /**销毁调用*/
        onDestroy(): void;
        /**
         * 外部调用本模块的操作
         * @type type 操作类型
         * @param param 参数
         */
        execute(type?: number, param?: any): void;
    }
}

declare module "odin" {
    export class NetObject {
        private _netGuid;
        private _friendNetGuid;
        constructor(netGuid: string, friendNetGuid: string);
        get friendNetGuid(): string;
        get netGuid(): string;
        /**
         * 将自己注册到Net上，可供远端调用
         */
        registerToNet(): void;
    }
}

declare module "odin" {
    export class NetObjectC<T> extends NetObject {
        private _server;
        private netFunNameMap;
        /**
         * 构造
         * @param netGuid 通信id
         * @param ServerClass 服务端类
         * @param autoRegisterToNet 是否自动注册到网络
         */
        constructor(netGuid: string, ServerClass: Class<T>, autoRegisterToNet?: boolean, friendNetGuid?: string);
        private serverClassToCallHandler;
        private replaceNetFun;
        private creatCallServerFun;
        /**
         * 调用服务端方法
         * @param fun 服务端方法名|服务端方法对象
         * @param prames 参数
         * @returns 方法返回值
         */
        protected callServerFun(fun: string | Function, ...prames: any[]): Promise<any>;
        /**
         * 和自己绑定的服务端对象，可通过此对象直接调用net_开头的服务端方法
         */
        protected get server(): T;
        /**获取当前玩家*/
        protected get currentPlayer(): GamePlay.Player;
        /**获取当前玩家id*/
        protected get currentPlayerId(): number;
    }
}

declare module "odin" {
    export abstract class ModuleC<T, S extends ModuleData<any>> extends NetObjectC<T> implements IModule {
        private ModuleDataClass;
        /**
         * 构造(不要手动构造模块，请在GameStart中注册)
         * @param ServerModuleClass 模块服务端类
         * @param ModuleDataClass 模块数据类
         * @param netGuid 通信id
         */
        constructor(ServerModuleClass: Class<T>, ModuleDataClass: Class<S>, netGuid: string, serverNetGuid: string);
        /**获取模块数据*/
        protected get data(): S;
        /**创建调用*/
        onAwake(): void;
        /**开始调用*/
        onStart(): void;
        /**进入场景调用*/
        onEnterScene(sceneType: number): void;
        /**刷新调用*/
        onUpdate(dt: number): void;
        /**销毁调用*/
        onDestroy(): void;
        /**
         * 外部调用本模块的某个操作
         * @type type 操作类型
         * @param param 参数
         */
        execute(type?: number, param?: any): void;
        /**预加载资源 */
        onRreloadAsset(sceneType: number): Promise<void>;
    }
}

declare module "odin" {
    export class NetObjectS<T> extends NetObject {
        private _client;
        private netFunNameMap;
        private callClientObj;
        /**
         * 构造
         * @param netGuid 通信id
         * @param ClientClass 客户端类
         * @param autoRegister 是否自动注册
         */
        constructor(netGuid: string, ClientClass: Class<T>, autoRegister?: boolean, friendNetGuid?: string);
        private clientClassToCallHandler;
        private replaceNetFun;
        private getCallClientFun;
        /**
         * 和自己绑定的客户端对象，可通过此对象直接调用net_开头的客户端方法
         */
        protected get client(): T;
        /** 当前调用服务器方法的玩家 */
        protected get currentPlayer(): GamePlay.Player;
        /** 当前调用服务器方法的玩家ID */
        protected get currentPlayerId(): number;
        /**
         * 调用目标客户端的方法
         * @param player 目标客户端
         * @param fun 方法名|方法对象|方法调用结果
         * @param params 参数
         */
        protected callClientFun(player: GamePlay.Player | number, fun: string | Function | void, ...params: any[]): void;
        /**
         * 调用目标周围客户端的方法
         * @param fun 方法名|方法对象|方法调用结果
         * @param params 参数
         */
        protected callAroundClientFun(fun: string | Function | void, ...params: any[]): void;
        /**
         * 调用所有客户端的方法
         * @param fun 方法名|方法对象|方法调用结果
         * @param params 参数
         */
        protected callWorldClientFun(fun: string | Function | void, ...params: any[]): void;
        private setCallClientObj;
    }
}

declare module "odin" {
    export abstract class ModuleS<T, S extends ModuleData<any>> extends NetObjectS<T> implements IModule {
        private ModuleDataClass;
        /**
         * 构造(不要手动构造模块，请在GameStart中注册)
         * @param ClientModuleClass 模块客户端类
         * @param ModuleDataClass 模块数据类
         * @param netGuid 通信id
         */
        constructor(ClientModuleClass: Class<T>, ModuleDataClass: Class<S>, netGuid: string, clientNetGuid: string);
        /** 获取当前请求玩家的本模块数据控制*/
        protected get currentData(): S;
        /**进入游戏的玩家字典*/
        protected get enterGamePlayerMap(): Map<number, GamePlay.Player>;
        /**
         * 获取玩家的本模块数据
         * @param player 目标玩家|目标玩家id
         * @returns 数据
         */
        protected getPlayerData(player: GamePlay.Player | number): S;
        /**创建调用*/
        onAwake(): void;
        /**开始调用*/
        onStart(): void;
        /**刷新调用*/
        onUpdate(dt: number): void;
        /**销毁调用*/
        onDestroy(): void;
        /**执行操作*/
        execute(param?: number, data?: any): void;
        /**玩家进入房间*/
        onPlayerJoined(player: GamePlay.Player): void;
        /**玩家离开房间*/
        onPlayerLeft(player: GamePlay.Player): void;
        /**玩家进入游戏*/
        onPlayerEnterGame(player: GamePlay.Player, reenter: boolean): void;
    }
}

declare module "odin" {
    /**模块管理*/
    export class ModuleManager {
        private static _instance;
        static get instance(): ModuleManager;
        destroy(): void;
        private moduleMapType;
        private moduleArr;
        private ClientFirstStartModule;
        private inGamePlayerMap;
        private constructor();
        /**
         * 注册模块
         * @param ServerModule 模块的服务端类型
         * @param ClientModule 模块的客户端类型
         * @param ModuleDataClass 模块的数据类型
         */
        register(ServerModule: Class<IModule>, ClientModule: Class<IModule>, ModuleDataClass: Class<ModuleData<any>>): void;
        /**
         * 设置客户端第一个要启动的模块
         * @param ModuleClass 模块类
         */
        setClientFirstStartModule(ModuleClass: Class<ModuleC<any, any>>): void;
        private registerModule;
        /**
         * 根据类型获取一个模块
         * @param ModuleClass 模块类型
         * @returns 模块
         */
        getModule<T extends IModule>(ModuleClass: Class<T>): T;
        private update;
        /**唤醒所有模块 */
        private awakeAllModule;
        /**启动所有模块 */
        private startAllModule;
        private startModule;
        /**
         * 启动第一个模块
         */
        private startClientFirstModule;
        /**
         * 所有模块等待资源
         * @param sceneType 场景类型
         */
        private preloadAssetAllModule;
        /**
         * 所有模块模块进入场景
         * @param sceneType 场景类型
         */
        private enterSceneAllModule;
        /**销毁所有模块 */
        private destroyAllModule;
        /**
         * 遍历所有模块
         * @param executer 每个模块执行的方法
         */
        forEachModule<T extends IModule>(executer: (moudle: T) => void, TypeFilter?: any): void;
        /**
         * 调用一个模块的Excut方法
         * @param ModuleClass 模块
         * @param type 操作类型
         * @param param 参数
         * @returns 结果
         */
        execut<T extends IModule>(ModuleClass: Class<T>, type: number, param?: any): any;
        start(onModuleAwake?: () => void, onFirstModuleStart?: () => void, onAllModuleStart?: () => void, onModulePreloadAssets?: () => void, onModuleEnterScene?: () => void): Promise<void>;
    }
}

declare module "odin" {
    export class Sound {
        static volumeScale: number;
        static bgmVolumeScale: number;
        onComplete: Action;
        playId: number;
        targetGuid: string;
        private go;
        private loopNum;
        private _resId;
        private _isDone;
        private _isError;
        private _volume;
        constructor(resId: string);
        private init;
        play(loopNum?: number, volume?: number): void;
        playInTarget(target: MWCore.GameObject, loopNum?: number, volume?: number): void;
        playInPos(pos: Type.Vector, loopNum?: number, volume?: number): void;
        private play3D;
        stop(): void;
        private clear;
        set volume(value: number);
        get volume(): number;
        get resId(): string;
        get isDone(): boolean;
        get isError(): boolean;
        clone(): Sound;
    }
}

declare module "odin" {
    export class SoundManager {
        private static _instance;
        static get instance(): SoundManager;
        private constructor();
        private static init;
        destroy(): void;
        readonly onPlaySoundComplete: Action1<string | number>;
        private currentPlayId;
        private soundMap;
        private pool;
        private playingSound;
        private bgm;
        private init;
        /**
         * 根据资源id播放声音（可双端调用，不可叠加)
         * @param resId 资源id
         * @param loopNum 循环次数(0无限)
         * @param volume 音量
         * @returns 资源id
         */
        playSound(resId: string, loopNum?: number, volume?: number): string;
        /**
         * 根据资源id停止声音
         * @param resId 资源id
         */
        stopSound(resId: string): void;
        /**
         * 停止除BGM以外的一切2D声音
         */
        stopAllSound(): void;
        /**
         * 播放背景音乐（可双端调用)
         * @param resId 资源id
         * @param volume 音量
         */
        playBGM(resId: string, volume?: number): void;
        /**
         * 停止背景音乐（可双端调用)
         */
        stopBGM(): void;
        /**
         * 在目标播放3D音效（可双端调用)
         * @param resId 资源id
         * @param target 播放目标 (GameObject的guid | GameObject | 世界坐标)
         * @param loopNum 循环次数
         * @param volume 音量
         * @returns 播放id，播放声音的唯一标识，可用于停止声音
         */
        play3DSound(resId: string, target: string | MWCore.GameObject | Type.Vector, loopNum?: number, volume?: number): number;
        private net_play3DSoundHandle;
        /**
         * 停止3D声音（可双端调用)
         * @param playId 播放id
         */
        stop3DSound(playId: number): void;
        /**
         * 停止一切3D声音（可双端调用)
         */
        stopAll3DSound(): void;
        /**
         * 音效的音量(Client Only)
         */
        set volumeScale(value: number);
        /**
         * 音效的音量(Client Only)
         */
        get volumeScale(): number;
        /**
         * BGM音量(Client Only)
         */
        set bgmVolumeScale(value: number);
        /**
         * BGM音量(Client Only)
         */
        get bgmVolumeScale(): number;
        private update;
        private getSound;
        private spawn3DSound;
        private return3DSound;
        private getNewPlayId;
    }
}

declare module "odin" {
    export class InputManager {
        static instance: InputManager;
        constructor();
        destroy(): void;
        private _onTouch;
        private touchInput;
        private beginMulFun;
        private keyDownActionMap;
        private init;
        /**
         * 鼠标点击触发，返回点击的所有结果
         */
        get onTouch(): Action1<Array<GamePlay.HitResult>>;
        /**
         * 按下键盘事件(增加了重复监听的判断，还可以移除监听方法)
         * @param key 按键类型
         * @returns 监听的Action方法
         */
        onKeyDown(key: Type.Keys): Action1<Type.Keys>;
        private initTouch;
        private touchBegin;
        private log;
    }
}

declare module "odin" {
    export enum UILayer {
        /**底层 */
        Bottom = 0,
        /**中层 */
        Middle = 1,
        /**独享层(调用此层会自动隐藏Bottom和Middle层) */
        Own = 2,
        /**顶层 */
        Top = 3
    }
}

declare module "odin" {
    export interface IPanel {
        /**UI对象*/
        get uiObject(): MWGameUI.MWUIWidget;
        /**画布*/
        get canvas(): MWGameUI.MWUICanvas;
        /**可见性*/
        get visible(): boolean;
        /**可见性*/
        set visible(value: boolean);
        /**是否处于显示状态*/
        get isShow(): boolean;
        /**名字*/
        get name(): string;
        /**
         * Panel放置的UI层
         */
        getLayer(): UILayer;
        /**
         * 显示Panel
         * @param params 参数
         */
        show(...params: any[]): void;
        /**
         * 隐藏Panel
         */
        hide(): void;
        /**
         * 销毁Panel
         */
        destroy(): void;
    }
}

declare module "odin" {
    export class UI extends MWGameUI.MWUIBehaviour {
        private static _instance;
        static get instance(): UI;
        private readonly LayerMap;
        private creatPanleMap;
        private uniquePanel;
        private _canvas;
        private onInitialized;
        private get canvas();
        /**
         * 显示一个界面(字符串调用)
         * @param panel 界面
         * @param layer 图层
         * @returns 显示的界面
         */
        private addChild;
        /**
         * 移除一个显示的界面(字符串调用)
         * @param panel 界面
         */
        private removeChild;
        /**
         * 根据界面类获取界面的对象
         * @param PanelClass 界面类型
         * @returns 界面对象
         */
        getPanel<T extends IPanel>(PanelClass: {
            new (): T;
            creat(): any;
        }): T;
        /**
         * 显示一个界面
         * @param PanelClass 界面的类
         * @param prames 显示参数(这个参数可以传递给界面的onShow方法)
         */
        showPanel<T extends IPanel>(PanelClass: {
            new (): T;
            creat(): T;
        }, ...prames: any[]): void;
        /**
         * 隐藏一个界面
         * @param PanelClass 界面的类
         */
        hidePanel<T extends IPanel>(PanelClass: {
            new (): T;
            creat(): T;
        }): void;
        /**
         * 销毁一个界面
         * @param PanelClass
         */
        destroyPanel<T extends IPanel>(PanelClass: {
            new (): T;
            creat(): T;
        }): void;
        /**
         * 判断界面是否处于显示状态(字符串调用)
         * @param panel 界面
         * @returns 是否显示
         */
        private panelIsShow;
        private setAllMiddleAndBottomPanelVisible;
        private getPanelLayer;
        private layoutWidget;
        /**判断UIRoot是否就绪*/
        static ready(): Promise<void>;
        /**
         * 获取屏幕尺寸
         * @returns 屏幕尺寸
         */
        static getCanvasSize(): Type.Vector2;
        /**
         * 将世界坐标转换到屏幕坐标
         * @param worldPos 世界坐标
         * @returns 屏幕坐标
         */
        static getCanvasPointByWorld(worldPos: Type.Vector): Type.Vector2;
    }
}

declare module "odin" {
    export abstract class OdinGame extends MWCore.MWScript {
        private consoleLevel;
        private languageIndex;
        private autoInit;
        /**注册模块*/
        protected abstract onRegisterModule(): void;
        onStart(): void;
        onUpdate(dt: number): void;
        onDestroy(): void;
        /**判断当前是否是单机模式 */
        static isListenServer(): boolean;
        /**手动初始化 */
        protected onInitClientByHand(): Promise<void>;
        /**所选择的语言索引(-1:系统 0:英语 1:汉语 2:日语 3:德语)*/
        protected get selectedLanguageIndex(): number;
        private exitGame;
        private initServer;
        /**初始化服务端*/
        private initClient;
        private showLoading;
        private showLog;
        /**
         * 当需要显示loading调用，需要请重写
         * @param msg 显示的提示内容
         * @param progress 进度条进度(0-1)
         * @param completeAotoClose 完成后是否自动关闭
         */
        protected onClientLoading(msg: string, progress: number, completeAotoClose: boolean): void;
    }
}

declare module "odin" {
    /**
     * MapEx(可序列化)
     */
    export namespace MapEx {
        type MapExClass<T> = {
            [key: string | number]: T;
        };
        /**
         * 获取对象
         * @param map
         * @param key
         * @returns
         */
        function get<T>(map: MapExClass<T>, key: string | number): T;
        /**
         * 设置对象
         * @param map
         * @param key
         * @param value
         */
        function set<T>(map: MapExClass<T>, key: string | number, value: T): void;
        /**
         * 删除对象
         * @param map
         * @param key
         * @returns 成功/失败
         */
        function del<T>(map: MapExClass<T>, key: string | number): boolean;
        /**
         * 是否有指定对象
         * @param map
         * @param key
         * @returns
         */
        function has<T>(map: MapExClass<T>, key: string | number): boolean;
        /**
         * 获取count数量
         * @param map
         * @param key
         * @returns
         */
        function count<T>(map: MapExClass<T>): number;
        /**
         * 遍历map
         * @param map
         * @param callback
         */
        function forEach<T>(map: MapExClass<T>, callback: (element: T) => void): void;
        /**
         * 拷贝，Val还是引用出来的，只是Map换了
         * @param map
         * @returns
         */
        function copy<T>(map: MapExClass<T>): MapExClass<T>;
        /**
         * 是否为空
         * @param map
         * @returns 是/否
         */
        function isNull<T>(map: MapExClass<T>): boolean;
    }
}

declare module "odin" {
    /**
     * 战斗对象抽象接口
     */
    export interface IFightRole {
        /**
        * 是否死亡
        */
        isDead: boolean;
        /**
         * 死亡动画播放完成，死透了
         */
        onDeadComplete(): void;
        /**
         * 当前位置
         */
        location: Type.Vector;
        /**
         * 角色对象
         */
        character: GamePlay.Character | GamePlay.Humanoid;
        /**
         * 被伤害
         * @param Attacker 攻击者
         * @param val 伤害值
         */
        onHurt(Attacker: IFightRole, val: number): void;
        /**
         * 移动到目的地
         * @param pos 目的地
         * @param radius 半径
         * @param callBack 移动完成回调
         */
        moveTo(pos: Type.Vector, radius: number, callBack: Function): void;
        /**
         * 停止移动
         */
        stopMove(): void;
        /**
         * 看向某个方向
         * @param pos 目标点
         */
        lookAt(pos: Type.Vector): any;
        /**
        * 是否在移动
        */
        isMoving(): boolean;
        /**
         * 获取一个可释放的技能
         */
        getSkill(): number;
        /**
         * 释放技能
         * @param target 目标
         * @param skill 技能id
         */
        releaseSkill(target: IFightRole, skill: number): void;
        /**
         * 最大可释放技能距离，寻路时候用
         */
        getMaxAttackDis(): number;
        /**
         * 最大追踪距离，超过了应该返回出生点
         */
        getMaxTrackDis(): number;
        /**
         * 检测当前对象是否合法可攻击
         */
        checkTargetValid(target: IFightRole): boolean;
        /**
         * 清除当前对象
         * @param target 和当前对象对比，一样的才清除
         */
        clearCurTarget(target: IFightRole): void;
        /**
         * 找一个对象
         */
        findATarget(): IFightRole;
        /**
         * 设置当前对象
         * @param target 目标对象
         */
        setCurTarget(target: IFightRole): void;
        /**
         * 当前锁定的对象
         */
        getCurTarget(): IFightRole;
        /**
         * 返回出生点的位置
         */
        getBack2Pos(): Type.Vector;
        /**
         * 找目标的视野
         */
        getEyeDis(): number;
        /**
         * 战斗实体类型，用来区分玩家，怪物等
         */
        getType(): number;
        /**
         * 更新
         */
        update(): void;
        /**
         * 遍历所有战斗对象
         * @param call 回调函数
         */
        forEachFightRole(call: (role: IFightRole) => void): void;
        /**
         * 播放动画
         * @param guid 动画guid
         * @param pos 目标位置
         */
        playAnimation(guid: string, pos: Type.Vector): any;
    }
}

declare module "odin" {
    export interface IAIState {
        /**
        * 状态进入，外部调用
        * @param context 战斗实体
        */
        enter(context: IFightRole): any;
        /**
         * 更新，外部驱动
         */
        onUpdate(): any;
        /**
         * 退出状态外部调用
         */
        exit(): any;
        /**
         * 销毁
         */
        onDestory(): any;
        /**
         * 切换状态
         * @param type 状态类型
         */
        change2State(type: number): void;
    }
}

declare module "odin" {
    export class AIMachine {
        private currentState;
        private stateMap;
        private owner;
        constructor(owner: IFightRole);
        /**
         * 注册状态
         * @param type 状态机类型
         * @param newstate 状态对象
         */
        register(type: number, newstate: IAIState): void;
        /**
        * 状态轮询：调用子状态
        */
        update(): void;
        /**
        * 切换状态：立即转换到新的状态（参数自己注册时填写）
        * @param type 新的状态
        */
        changeState(type: number): void;
        destory(): void;
    }
}

declare module "odin" {
    export abstract class AIState implements IAIState {
        protected context: IFightRole;
        protected owner: AIMachine;
        constructor(owner: AIMachine);
        /**
         * 切换状态
         * @param type 状态类型
         */
        change2State(type: number): void;
        /**
         * 状态进入，外部调用
         * @param context 战斗实体
         */
        enter(context: IFightRole): void;
        /**
         * 退出状态外部调用
         */
        exit(): void;
        /**
         * 销毁
         */
        onDestory(): void;
        /**
         * 子状态重写，enter之后触发
         */
        protected abstract onEnter(): any;
        /**
        * 子状态重写，exit之后触发
        */
        protected abstract onExit(): any;
        /**
         * 更新，外部驱动
         */
        abstract onUpdate(): any;
    }
}

declare module "odin" {
    /**Canvas控制类的基类*/
    export class CanvasController {
        private _canvas;
        private _visible;
        protected constructor(canvas: MWGameUI.MWUICanvas);
        /**
         * 创建一个CanvasController
         * @param canvas ui画布
         * @returns CanvasController
         */
        static creat<T extends CanvasController>(canvas: MWGameUI.MWUICanvas): T;
        /**构建自己，可以在其中写一个要Find的子节点*/
        protected buildSelf(): void;
        /**
         * 根据类型和路径查找子对象
         * @param ChildType 子对象的类型
         * @param path 节点路径
         * @returns 子节点对象
         */
        protected getChild<T extends MWGameUI.MWUIWidget>(ChildType: {
            new (...param: any[]): T;
            Get(p: MWGameUI.MWUIWidget): T;
        }, path: string): T;
        /**画布*/
        get canvas(): MWGameUI.MWUICanvas;
        /**可见性*/
        set visible(value: boolean);
        /**可见性*/
        get visible(): boolean;
    }
}

declare module "odin" {
    /**
     * 批量Events监听处理
     * 可以将一批注册的事件同时激活或屏蔽
     */
    export class EventListenerBatch {
        private _active;
        private addMap;
        private listenerMap;
        /**
         * 注册监听事件
         * @param eventName 事件名
         * @param callback 监听方法
         */
        add(eventName: string, callback: (...params: unknown[]) => void): void;
        /**
         * 移除监听事件
         * @param eventName 事件名
         */
        remove(eventName: string): void;
        /**
         * 清理所有监听事件
         */
        clear(): void;
        /**是否生效*/
        set active(value: boolean);
        /**是否生效*/
        get active(): boolean;
    }
}

declare module "odin" {
    export class PanelBase extends MWGameUI.MWUIBehaviour implements IPanel {
        private uiPrefab;
        private _visible;
        private _eventListener;
        private isEnabel;
        /**
         * 根据prefab路径，创建一个Panel
         * @param prefabPath ui文件的路径
         * @returns Panel
         */
        static creat<T extends PanelBase>(prefabPath: string): T;
        private onInitialized;
        private preConstruct;
        private construct;
        /**
         * 根据节点路径查找一个界面元素
         * @param ObjClass 元素类型
         * @param path 节点路径
         * @returns 元素对象
         */
        protected findChildByPath<T extends MWGameUI.MWUIWidget>(ObjClass: {
            new (): T;
            Get(p: MWGameUI.MWUIWidget): T;
        }, path: string): T;
        get canvas(): MWGameUI.MWUICanvas;
        get uiObject(): MWGameUI.MWUIWidget;
        set visible(value: boolean);
        get visible(): boolean;
        show(...params: any[]): this;
        hide(): void;
        /**是否处于显示状态*/
        get isShow(): boolean;
        /**名字*/
        get name(): string;
        /**事件批处理*/
        get localEventListener(): EventListenerBatch;
        /**
         * 获取这个Panle应该显示在的UI层，默认在Middle层，如果想换层请复写这个方法
         * @returns UI层
         */
        getLayer(): UILayer;
        /**销毁Panel */
        destroy(): void;
        private enable;
        private disable;
        /**
         * 创建调用
         */
        protected onAwake(): void;
        /**
         * 开始调用
         */
        protected onStart(): void;
        /**
         * 局部完成调用，隐藏的对象不参与UI布局，所以要布局完成后再隐藏，这个方法就是布局完成后调用
         */
        protected onLayout(): void;
        /**
         * 激活调用(每次显示都会调用)
         */
        protected onEnable(): void;
        /**
         * 禁用调用(每次隐藏都会调用)
         */
        protected onDisable(): void;
        /**
         * show调用
         * @param params show方法传递的参数
         */
        protected onShow(...params: any[]): void;
        /**
         * close调用
         */
        protected onHide(): void;
        /**
         * 销毁调用
         */
        protected onDestroy(): void;
        /**
         * 刷新调用
         * @param dt 帧间隔时间
         */
        protected onUpdate(dt: number): void;
    }
}

declare module "odin" {
    export class ViewBase implements IPanel {
        private prefab;
        private _visible;
        private _eventListener;
        private defaultPrefabPath;
        protected constructor(prefabPath: string);
        buildSelf(): void;
        /**
         * 根据prefab路径，创建一个Panel
         * @param prefabPath ui文件的路径
         * @returns Panel
         */
        static creat<T extends ViewBase>(prefabPath?: string): T;
        /**
         * 根据节点路径查找一个界面元素
         * @param ObjClass 元素类型
         * @param path 节点路径
         * @returns 元素对象
         */
        findChildByPath<T extends MWGameUI.MWUIWidget>(ObjClass: {
            new (): T;
            Get(p: MWGameUI.MWUIWidget): T;
        }, path: string): T;
        /**
         * 获取一个节点下名字有规律的子对象，路径是这种形式：`Canvas/Con/Field{0}_txt`
         * @param ObjClass 子对象类型
         * @param path 节点路径
         * @param startIndex 规律标记的起始值
         * @param emdIndex 规律标记的结束值(不包含)
         * @returns 子对象队列
         */
        findChildrenByPath<T extends MWGameUI.MWUIWidget>(ObjClass: {
            new (): T;
            Get(p: MWGameUI.MWUIWidget): T;
        }, path: string, startIndex?: number, endIndex?: number): Array<T>;
        /**
         * 根据类型，获取画布下的所有此类型的对象
         * @param canvas 画布
         * @param ObjClass 类型类型
         * @returns 对象数组
         */
        static getCanvasChildren<T extends MWGameUI.MWUIWidget>(canvas: MWGameUI.MWUICanvas, ObjClass: {
            new (): T;
            Get(p: MWGameUI.MWUIWidget): T;
        }): Array<T>;
        /**
         * 将UI节点转换为实际的UI元素对象
         * @param EleClass UI元素的类
         * @param widget 节点对象
         * @returns UI元素对象
         */
        private static widgetToUIElement;
        /**
         * 根据路径获取一个Canvas，并返回控制这个Canvas的控制器对象
         * @param ControllerClass Canvas控制器类
         * @param path 路径
         * @returns Canvas控制器对象
         */
        findCanvasByPath<T extends CanvasController>(ControllerClass: Class<T>, path: string): T;
        get canvas(): MWGameUI.MWUICanvas;
        get uiObject(): MWGameUI.MWUIUserWidgetPrefab;
        set visible(value: boolean);
        get visible(): boolean;
        show(...params: any[]): this;
        hide(): void;
        /**是否处于显示状态*/
        get isShow(): boolean;
        /**名字*/
        get name(): string;
        /**
         * 获取这个Panle应该显示在的UI层，默认在Middle层，如果想换层请复写这个方法
         * @returns UI层
         */
        getLayer(): UILayer;
        /**销毁Panel */
        destroy(): void;
        /**事件批处理*/
        get localEventListener(): EventListenerBatch;
        private enable;
        private disable;
        /**
         * 开始调用
         */
        protected onStart(): void;
        /**
         * 局部完成调用，隐藏的对象不参与UI布局，所以要布局完成后再隐藏，这个方法就是布局完成后调用
         */
        protected onLayout(): void;
        /**
         * 激活调用
         */
        protected onEnable(): void;
        /**
         * 禁用调用
         */
        protected onDisable(): void;
        /**
         * show调用
         * @param params show方法传递的参数
         */
        protected onShow(...params: any[]): void;
        /**
         * close调用
         */
        protected onHide(): void;
        /**
         * 销毁调用
         */
        protected onDestroy(): void;
        /**
         * 刷新调用
         * @param dt 帧间隔时间
         */
        protected onUpdate(dt: number): void;
    }
}

declare module "odin" {
    export class SuperPanelBase<T extends ViewBase> implements IPanel {
        private _view;
        private ViewClass;
        /**
         * 不可以直接实例化
         * @param ViewClass view的类
         */
        constructor(ViewClass: Class<T>);
        get view(): T;
        /**
         * 从界面类型，创建一个Panel
         * @returns Panel
         */
        static creat<T extends SuperPanelBase<ViewBase>>(): T;
        protected buildSelf(): void;
        /**画布*/
        get canvas(): MWGameUI.MWUICanvas;
        /**UI对象*/
        get uiObject(): MWGameUI.MWUIUserWidgetPrefab;
        /**可见性*/
        set visible(value: boolean);
        /**可见性*/
        get visible(): boolean;
        /**显示Panel*/
        show(...params: any[]): this;
        /**隐藏Panel*/
        hide(): void;
        /**是否处于显示状态*/
        get isShow(): boolean;
        /**名字*/
        get name(): string;
        /**
         * 获取这个Panle应该显示在的UI层，默认在Middle层，如果想换层请复写这个方法
         * @returns UI层
         */
        getLayer(): UILayer;
        /**销毁Panel */
        destroy(): void;
        /**事件批处理*/
        get localEventListener(): EventListenerBatch;
        private enable;
        private disable;
        private _size;
        /**界面尺寸 */
        get size(): Type.Vector2;
        /**界面尺寸 */
        set size(value: Type.Vector2);
        set position(pos: Type.Vector2);
        addToParent(parent: MWGameUI.MWUICanvas): void;
        removeFromParent(): void;
        /**
         * 开始调用
         */
        protected onStart(): void;
        /**
         * 局部完成调用，隐藏的对象不参与UI布局，所以要布局完成后再隐藏，这个方法就是布局完成后调用
         */
        protected onLayout(): void;
        /**
         * 激活调用
         */
        protected onEnable(): void;
        /**
         * 禁用调用
         */
        protected onDisable(): void;
        /**
         * show调用
         * @param params show方法传递的参数
         */
        protected onShow(...params: any[]): void;
        /**
         * hide调用
         */
        protected onHide(): void;
        /**
         * 销毁调用
         */
        protected onDestroy(): void;
        /**
         * 刷新调用
         * @param dt 帧间隔时间
         */
        protected onUpdate(dt: number): void;
    }
}

declare module "odin" {
    export class TabGroup<T extends {
        onClicked(): MWGameUI.MWUIMulticastDelegate<() => void>;
    }> {
        private tabArr;
        private selectCallBack;
        private selectChecker;
        private tabStyleHandle;
        private _currentIndex;
        /**
         * 构造
         * @param tabArr 标签的按钮数组
         */
        constructor(tabArr: Array<T>);
        /**
         * 初始化
         * @param tabStyleHandle 设置标签的样式方法（方法参数：按钮）
         * @param selectCallBack 选择标签的回调方法
         * @param thisArg 域
         * @param defaultIndex 默认选择的标签索引
         */
        init(tabStyleHandle: (btn: T, isSelect: boolean) => void, selectCallBack: (index: number) => void, thisArg: any, defaultIndex?: number): void;
        /**
         * 设置标签是否可选择的判断方法
         * @param selectChecker 判断方法
         * @param thisArg 域
         */
        setSelectChecker(selectChecker: (index: number) => boolean, thisArg: any): void;
        /**
         * 设置当前的标签
         * @param index 标签索引
         * @param ignoreSame 是否忽略相同索引
         * @returns 是否成功
         */
        select(index: number, ignoreSame?: boolean): boolean;
        /**当前选择的标签索引 */
        get currentIndex(): number;
        private refreshTabs;
    }
}

declare module "odin" {
    export abstract class AnalyticsUtil {
        private static readonly NET_MSG_SEND_MGS;
        private static comData;
        private static msgMap;
        /** 初始化*/
        private static init;
        /**
         * 设置公共数据，每个埋点数据都会附加的字段，由key,value的形式组织
         * @param comData 公共数据
         */
        static setCommonData(comData: any): void;
        /** 根据类型生成一个埋点数据对象
         * @param MsgClass 埋点数据类
         * @returns 数据对象
         */
        static get<T extends AnalyticsUtil>(MsgClass: Class<T>): T;
        /**数据说明 */
        abstract desc: string;
        /**数据体 */
        abstract data: any;
        /**
         * 上传埋点数据到潘多拉
         * @param player 在服务端调用时，指定埋点的玩家，如果不写则全房间玩家都上传
         */
        send(player?: GamePlay.Player): void;
    }
    export class ts_splash_loading_start extends AnalyticsUtil {
        desc: string;
        data: {};
    }
    export class ts_splash_loading_end extends AnalyticsUtil {
        desc: string;
        data: {
            deltatime: number;
        };
    }
}

declare module "odin" {
    /**
     * 摄像机工具类，用于实现震屏、摄像机跟随等效果
     */
    export class CameraUtil {
        private static _character;
        private static forward;
        private static speed;
        private static maxRange;
        private static lastOffSize;
        private static decay;
        private static get character();
        /**
         * 震屏
         * @param maxRange 最大幅度
         * @param decay 每个周期的衰减
         * @param speed 速度
         */
        static screenShock(maxRange?: number, decay?: number, speed?: number): void;
        private static screenShockFinish;
        private static screenShockUpdate;
        /**
         * 跟随目标
         * @param target 目标
         */
        static setFollowTarget(target: MWCore.GameObject): void;
    }
}

declare module "odin" {
    /**
     *广告类型
     */
    export enum ADSType {
        /**
         * 激励
         */
        Reward = "reward",
        /**
         * 插屏
         */
        Interstitial = "interstitial"
    }
    /**
     * 激励，插屏广告接口
     * 主要用于广告的是否准备好，预加载，显示
     *
     */
    export class IAAServiceSDK {
        private static _instance;
        static get instance(): IAAServiceSDK;
        needLog: boolean;
        private map;
        private register;
        /**
         *
         * @param _actionName
         * @param _func 是否播放成功
         * @param _func1 reward 激励视频show类型的时候播放完成回调，完成后可以进行奖励操作
         */
        private send;
        private callBack;
        /**
         *
         * @param _adsType 广告类型
         */
        show(_adsType: ADSType, _callBack: Function): void;
        private onRewardReady;
        private onRewardLoad;
        private onInterstitialReady;
        private onInterstitialLoad;
    }
}

declare module "odin" {
    /**
     * 数学工具
     */
    export class MathUtil {
        /**
         * 获取两个向量之间的距离
         * @param v1 第一个向量
         * @param v2 第二个向量
         * @returns 距离
         */
        static distance(v1: Type.Vector, v2: Type.Vector): number;
        /**
         * 获取两个向量之间的距离的平方
         * @param v1 第一个向量
         * @param v2 第二个向量
         * @returns 距离
         */
        static distanceSquare(v1: Type.Vector, v2: Type.Vector): number;
        /**
         * 一个点往目标点移动一个距离
         * @param currentPos 当前点
         * @param targetPos 目标点
         * @param moveDis 移动的距离
         * @param resPos 移动后得到的结果的点
         * @returns 是否移动到了目标点
         */
        static posMove(currentPos: Type.Vector, targetPos: Type.Vector, moveDis: number, resPos: Type.Vector): boolean;
        /**
         * 向量的线性插值
         * @param from 起始向量
         * @param to 目标向量
         * @param alpha alpha
         * @returns 新向量
         */
        static vectorLerp(from: Type.Vector, to: Type.Vector, alpha: number): Type.Vector;
        /**
         * 获取一个区间的整随机数
         * @param min 最小值
         * @param max 最大值(不包含)
         * @returns 随机数
         */
        static getRandom(min: number, max: number): number;
        /**
         * 获取两个旋转之间的欧拉角
         * @param from 起始旋转
         * @param to 目标旋转
         * @returns 欧拉角
         */
        static getEulerAngles(from: Type.Rotation, to: Type.Rotation): Type.Vector;
        /**
         * Rotation转欧拉角
         * @param rotation Rotation
         * @returns 欧拉角
         */
        static rotationToAngles(rotation: Type.Rotation): Type.Vector;
        /**
         * 获取局部欧拉角
         * @param go GameObject
         * @returns 欧拉角
         */
        static getLocalEulerAngles(go: MWCore.GameObject): Type.Vector;
        /**
         * 向量点积
         * @param a 第一个向量
         * @param b 第二个向量
         * @returns 点积结果
         */
        static dot(a: Type.Vector, b: Type.Vector): number;
        /**
         * 向量叉积
         * @param a 第一个向量
         * @param b 第二个向量
         * @returns 叉积结果
         */
        static cross(a: Type.Vector, b: Type.Vector): Type.Vector;
        /**
         * 获取两个向量的旋转角
         * @param from 起始向量
         * @param to 目标向量
         * @param up 旋转轴
         * @returns 旋转的角度
         */
        static getSignedAngle(from: Type.Vector, to: Type.Vector, up: Type.Vector): number;
    }
}

declare module "odin" {
    export class GoPool {
        static instance: GoPool;
        constructor();
        destroy(): void;
        private readonly POOL_RES_GUID;
        private sourceTypeMap;
        private sceneSource;
        private subPoolMap;
        /**
         * 生成一个对象
         * @param guid 场景对象的guid | 资源的guid | prefab的guid
         * @returns 对象
         */
        spawn<T extends MWCore.GameObject>(guid: string): T;
        private getSourceType;
        /**
         * 归还一个对象
         * @param obj 对象
         */
        unSpawn(obj: MWCore.GameObject): void;
        /**
         * 清除对象池中所以guid对应的对象
         * @param guid 清除对象的guid
         */
        clear(guid: string): void;
    }
    export class ObjPool<T> {
        private creatFunction;
        private resetFunction;
        private destroyFunction;
        private freeObjs;
        /**
         * 构造一个对象池
         * @param creatObj 创建新对象的回调
         * @param onReset 重置对象的回调
         * @param onDestroy 销毁对象的回调
         * @param initNum 默认缓存对象数量
         */
        constructor(creatObj: () => T, onReset: (obj: T) => void, onDestroy: (obj: T) => void, initNum?: number);
        /**
         * 生成一个对象
         * @returns 对象
         */
        spawn(): T;
        /**
         * 归还一个对象
         * @param obj 对象
         */
        unSpawn(obj: T): void;
        /**
         * 获取对象池中空闲对象的数量
         */
        get size(): number;
        /**
         * 清除
         */
        clear(): void;
        getFreeObjs(): Array<T>;
    }
}

declare module "odin" {
    /**
     * Tween.js - Licensed under the MIT license
     * https://github.com/tweenjs/tween.js
     * ----------------------------------------------
     *
     * See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors.
     * Thank you all, you're awesome!
     */
    export class Sequence {
        private static _nextId;
        static nextId(): number;
    }
    export let now: () => number;
    export type InterpolationFunction = (v: number[], k: number) => number;
    /**
     *
     */
    export const Interpolation: {
        Linear: (v: number[], k: number) => number;
        Bezier: (v: number[], k: number) => number;
        CatmullRom: (v: number[], k: number) => number;
        Utils: {
            Linear: (p0: number, p1: number, t: number) => number;
            Bernstein: (n: number, i: number) => number;
            Factorial: (n: number) => number;
            CatmullRom: (p0: number, p1: number, p2: number, p3: number, t: number) => number;
        };
    };
    export class Group {
        private _tweens;
        private _tweensAddedDuringUpdate;
        getAll(): Array<Tween<UnknownProps>>;
        removeAll(): void;
        add(tween: Tween<UnknownProps>): void;
        remove(tween: Tween<UnknownProps>): void;
        update(time?: number, preserve?: boolean): boolean;
    }
    export const mainGroup: Group;
    export type EasingFunction = (amount: number) => number;
    /**
     * The Ease class provides a collection of easing functions for use with tween.js.
     */
    export const Easing: {
        Linear: {
            None: (amount: number) => number;
        };
        Quadratic: {
            In: (amount: number) => number;
            Out: (amount: number) => number;
            InOut: (amount: number) => number;
        };
        Cubic: {
            In: (amount: number) => number;
            Out: (amount: number) => number;
            InOut: (amount: number) => number;
        };
        Quartic: {
            In: (amount: number) => number;
            Out: (amount: number) => number;
            InOut: (amount: number) => number;
        };
        Quintic: {
            In: (amount: number) => number;
            Out: (amount: number) => number;
            InOut: (amount: number) => number;
        };
        Sinusoidal: {
            In: (amount: number) => number;
            Out: (amount: number) => number;
            InOut: (amount: number) => number;
        };
        Exponential: {
            In: (amount: number) => number;
            Out: (amount: number) => number;
            InOut: (amount: number) => number;
        };
        Circular: {
            In: (amount: number) => number;
            Out: (amount: number) => number;
            InOut: (amount: number) => number;
        };
        Elastic: {
            In: (amount: number) => number;
            Out: (amount: number) => number;
            InOut: (amount: number) => number;
        };
        Back: {
            In: (amount: number) => number;
            Out: (amount: number) => number;
            InOut: (amount: number) => number;
        };
        Bounce: {
            In: (amount: number) => number;
            Out: (amount: number) => number;
            InOut: (amount: number) => number;
        };
        generatePow: (power?: number) => {
            In(amount: number): number;
            Out(amount: number): number;
            InOut(amount: number): number;
        };
    };
    export class Tween<T extends UnknownProps> {
        private _object;
        private _group;
        private _isPaused;
        private _pauseStart;
        private _valuesStart;
        private _valuesEnd;
        private _valuesStartRepeat;
        private _duration;
        private _initialRepeat;
        private _repeat;
        private _repeatDelayTime?;
        private _yoyo;
        private _isPlaying;
        private _reversed;
        private _delayTime;
        private _startTime;
        private _easingFunction;
        private _interpolationFunction;
        private _chainedTweens;
        private _onStartCallback?;
        private _onStartCallbackFired;
        private _onUpdateCallback?;
        private _onRepeatCallback?;
        private _onCompleteCallback?;
        private _onStopCallback?;
        private _id;
        private _isChainStopped;
        constructor(_object: T, _group?: Group | false);
        getId(): number;
        isPlaying(): boolean;
        isPaused(): boolean;
        to(properties: UnknownProps, duration?: number): this;
        duration(d?: number): this;
        start(time?: number): this;
        private _setupProperties;
        stop(): this;
        end(): this;
        pause(time?: number): this;
        resume(time?: number): this;
        stopChainedTweens(): this;
        group(group?: Group): this;
        delay(amount?: number): this;
        repeat(times?: number): this;
        repeatDelay(amount?: number): this;
        yoyo(yoyo?: boolean): this;
        easing(easingFunction?: EasingFunction): this;
        interpolation(interpolationFunction?: InterpolationFunction): this;
        chain(...tweens: Array<Tween<any>>): this;
        onStart(callback?: (object: T) => void): this;
        onUpdate(callback?: (object: T, elapsed: number) => void): this;
        onRepeat(callback?: (object: T) => void): this;
        onComplete(callback?: (object: T) => void): this;
        onStop(callback?: (object: T) => void): this;
        private _goToEnd;
        /**
         * @returns true if the tween is still playing after the update, false
         * otherwise (calling update on a paused tween still returns true because
         * it is still playing, just paused).
         */
        update(time?: number, autoStart?: boolean): boolean;
        private _updateProperties;
        private _handleRelativeValue;
        private _swapEndStartRepeatValues;
    }
    export type UnknownProps = Record<string, any>;
    export default Tween;
    const VERSION = "18.6.4";
    const nextId: typeof Sequence.nextId;
    const getAll: any;
    const removeAll: any;
    const add: any;
    const remove: any;
    const update: any;
    export { nextId, VERSION, getAll, removeAll, add, remove, update };
}

declare module "odin" {
    export class NetMWScript extends MWCore.MWScript {
        private _netEnable;
        /**是否开启net通信 */
        protected set netEnable(value: boolean);
        /**
         * 调用服务端方法
         * @param fun 方法路径|方法
         * @param params 参数
         * @returns 服务端方法返回值(异步)
         */
        protected callServerFun(fun: Function, ...params: any[]): Promise<any>;
        /**
         * 调用目标客户端的方法
         * @param player 目标玩家
         * @param fun 方法路径|方法
         * @param params 参数
         */
        protected callClientFun(player: GamePlay.Player, fun: Function, ...params: any[]): void;
        /**
         * 调用目标玩家周围客户端的方法
         * @param fun 方法路径|方法
         * @param params 参数
         */
        protected callAroundClientFun(fun: Function, ...params: any[]): void;
        /**
         * 调用所有客户端的方法
         * @param fun 方法路径|方法
         * @param params 参数
         */
        protected callWorldClientFun(fun: Function, ...params: any[]): void;
    }
}
//# sourceMappingURL=index.d.ts.map
